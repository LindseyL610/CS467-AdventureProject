from Utilities import say

# parser: get input and identify parts:
# verb, dobj, prep, iobj.
# Check against *master* word list, which is generated by looking at
#  all things, rooms, and verbs, and their alternate words. translate words to their common name.
# Give feedback if prompt cannot be parsed

# action:
# make sure verb has a use case with given "parts" (e.g. dobj, iobj)
# otherwise give general error feedback (or more specific feedback if they messed up in a predicted way?)
# Look at words, make sure they are relevant (objects that are in inventory/current room and verbs that are known)
# (you can use room.get_all_accessible_contents() )
# make sure direct/indirect objects are of the correct type (e.g. in_inventory vs in_room)
# If all arguments are appropriate, call the verb on the correct object.
#  Most verbs that can be used by themselves, with no objects (like "look" or "jump")
#  will be called on the Room (Room.look() or Room.jump())
#  Otherwise the verb will be called on the direct object. (special cases exist, like "go")
# Note that when calling the method the arguments should be the current game object
#  (containing player and room/thing lists) and arguments, e.g. Thing.look(game, actionargs)

class Action():
    """This class defines the unique characteristics for specific actions."""

    def __init__(self, name):
        self.name = name
        # We can create a default improper use message that is still specific to the verb,
        #  like below (but probably better)
        # Or if a verb's default message doesn't fit this mold, it can be refined for that object.

        self.msg_improper_use = "I don't know what you mean. Are you trying to {}?".format(self.name)
        # object types can be in_inventory, in_room, or any
        self.dobj_type = "any"
        self.iobj_type = "any"
        # define use cases

    def execute(self, game, actionargs):
        pass


class ActionDirect(Action):
    def execute(self, game, actionargs):
        if  "dobj" not in actionargs.keys() or "iobj" in actionargs.keys():
            say(self.msg_improper_use)
        else:
            # check dobj type and if accessible
            # get dobj (from thing list), and do action
            pass


class ActionDirectAndIndirect(Action):
    def execute(self, game, actionargs):
        if "dobj" not in actionargs.keys() or "iobj" not in actionargs.keys():
            say(self.msg_improper_use)
        else:
            # check dobj type and if accessible
            # check iobj type and if accessible
            # get dobj (from thing list), and do action


            pass


# create actions

# look (special case; likely needs own subclass)
# only verb "look"-> Room.look()
# verb + dobj(any) "look door"-> Thing.look()

# look_at
# verb + dobj(any) "look at door" -> redirects to look() -> Thing.look()

# go (special case; likely needs own subclass)
# used with direction "go up" or "up" -> Room.go()
# used with Exit name "go door" or "door" -> Exit.go()

# read
# verb + dobj(inventory/in room) "read book" -> Thing.read()
read = ActionDirect("read")

# take
# verb + dobj(in room) "take cheese" -> Thing.take()
take = ActionDirect("take")
take.dobj_type = "in_room"

# drop
# verb + dobj(inventory) "drop floppy" -> Thing.drop()
drop = ActionDirect("drop")
take.dobj_type = "in_inventory"

# put in
# verb + dobj(inventory) + iobj(any) "put cheese in fridge" -> Thing.put_in()
put_in = ActionDirectAndIndirect("put_in")
put_in.dobj_type = "in_inventory"

# put on
# verb + dobj (inventory) + iobj(any) "put book on table" -> Thing.put_on()
put_on = ActionDirectAndIndirect("put_on")
put_in.dobj_type = "in_inventory"

# give to
# verb + dobj (inventory) + iobj(any) "give cheese to mouse" -> Thing.give_to()
give_to = ActionDirectAndIndirect("give_to")
give_to.dobj_type = "in_inventory"

#create list of all verbs that can be searched
verb_list = []



